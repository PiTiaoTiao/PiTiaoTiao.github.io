[{"content":"设置符号断点，有以下几种方式：\nStyle 1、Breakpoint navigator Style 2、Debug -\u0026gt; Breakpoints -\u0026gt; Create Symbolic Breakpoint... Style 3、快捷键：option + command + \\ 如上图所示！\n","date":"2023-06-06T00:00:00Z","image":"https://pitiaotiao.github.io/p/20230606/20230606_hu18931e06667dd8dede62175ea838da33_230338_120x120_fill_q75_box_smart1.jpeg","permalink":"https://pitiaotiao.github.io/p/20230606/","title":"设置符号断点（Symbolic Breakpoint）的几种方式"},{"content":"一、下载Flutter SDK 1. 去Flutter官网下载最新安装包 2. 配置Flutter SDK到指定目录 二、配置Flutter开发环境 【注意】 如果Mac没有安装Homebrew,可通过下面的命令安装：\n1 /usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; 检查Homebrew版本：\n1 2 3 4 5 6 7 brew --version /* Homebrew 3.2.16 Homebrew/homebrew-core (git revision f7d7160e185; last commit 2021-10-12) Homebrew/homebrew-cask (git revision d101c8d60c; last commit 2021-10-12) */ 2.1、进入用户home目录 1 cd ~/ 2.2、打开.bash_profile并编辑 1 open .bash_profile 在.bash_profile中添加：\n1 2 3 4 5 # Flutter export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn export PATH=/Users/peijianbo/Documents/Flutter/flutter/bin:$PATH # Flutter END 【提醒】 其中/Users/klcw/peijianbo/Flutter/flutter是我自己电脑对应的Flutter SDK的目录，你需要修改为你的Flutter SDK对应的目录。\n【注意】 除了export后有个空格，其它地方不要有空格。\n2.3、command + s保存修改并关闭.bash_profile 2.4、令修改后的配置生效 1 source .bash_profile 2.5、检查Flutter开发环境是否可用 1 flutter doctor 出现如上图的终端，就说明Flutter的开发环境配置成功了。\n","date":"2022-04-09T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2022/20220409.jpeg","permalink":"https://pitiaotiao.github.io/p/flutter-config/","title":"Mac上Flutter开发环境配置"},{"content":"截止目前（2021-10-16）为止，要想实现下面的几种button样式（这里要考虑图片和文字间距），我所知道的方案有两种：\n给UIButton添加分类\n自定义UIButton\n而在实际开发中，我们使用 方案1 应该是最多的！\n自我参加工作（2015-06）以来，对于UIButton如上图的需求就一直有，而且还有很多！说实话，我也一直困惑，苹果爸爸问什么不支持一下呢？\n也许是有人不停地给苹果爸爸提issue， 也许是苹果爸爸也遇到大量的如此需求， 也许苹果爸爸做了统计发现几乎所有APP都有UIButton这类Categroy（Swift是Extension）, 也许苹果爸爸终于闲了有时间管了， 也许\u0026hellip;， 不管怎么说，iOS15，苹果爸爸支持了！而且API也如预期的那样简单：\n1 2 3 4 5 6 var conf = UIButton.Configuration.borderedTinted() /// 设置图片的摆放（图片在上，则文字在下） conf.imagePlacement = .top /// 设置图片和文字的间距 conf.imagePadding = 10 let bt = UIButton.init(configuration: conf, primaryAction: nil) 插一句：对于configuration这样的API设计，我是非常认可的，一看就知道是干什么用的！感觉苹果爸爸也有意如此设计，比如iOS14开始的的PHPickerConfiguration等。\n而我能发现这个，源自今天（2021-10-16）下午，打算用Swift重写老项目（《酷乐潮玩》）的一个推荐列表页，其中cell上有如下几个按钮，我想参考OC写的UIButton的category，也写个Swift版的：\n可是，在敲titleedg时，竟提示'titleEdgeInsets' will be deprecated in iOS 15.0。这瞬间激起了我的兴趣，于是点击进去一探究竟！\nSwift版UIButtonConfiguration： Objective-C版UIButtonConfiguration： 于是，我粗略地写了个demo验证一下，最终效果图：\n具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view. view.backgroundColor = .white test() } func test() { var conf1 = UIButton.Configuration.plain() conf1.title = \u0026#34;点赞\u0026#34; conf1.image = UIImage(named: \u0026#34;liked\u0026#34;) conf1.imagePlacement = .leading conf1.imagePadding = 10 let bt1 = UIButton.init(configuration: conf1, primaryAction: nil) var conf2 = UIButton.Configuration.bordered() conf2.title = \u0026#34;点赞\u0026#34; conf2.image = UIImage(named: \u0026#34;liked\u0026#34;) conf2.imagePlacement = .trailing conf2.imagePadding = 40 let bt2 = UIButton.init(configuration: conf2, primaryAction: nil) var conf3 = UIButton.Configuration.borderedTinted() conf3.title = \u0026#34;点赞\u0026#34; conf3.image = UIImage(named: \u0026#34;liked\u0026#34;) conf3.imagePlacement = .top conf3.imagePadding = 10 let bt3 = UIButton.init(configuration: conf3, primaryAction: nil) var conf4 = UIButton.Configuration.gray() conf4.title = \u0026#34;点赞\u0026#34; conf4.image = UIImage(named: \u0026#34;liked\u0026#34;) conf4.imagePlacement = .bottom conf4.imagePadding = 10 let bt4 = UIButton.init(configuration: conf4, primaryAction: nil) bt1.frame = CGRect(x: 50, y: 100, width: 100, height: 80) bt2.frame = CGRect(x: 200, y: 100, width: 150, height: 80) bt3.frame = CGRect(x: 50, y: 230, width: 100, height: 80) bt4.frame = CGRect(x: 200, y: 230, width: 100, height: 80) view.addSubview(bt1) view.addSubview(bt2) view.addSubview(bt3) view.addSubview(bt4) } } 最后，话又说回来了，目前我们的APP不可能是从iOS15开始的，估计大多数是从iOS11开始的，还有一部分是从iOS9开始，也有一部分是从iOS13开始的，所以 做好兼容还是很有必要的！\n而更多关于UIButton的新知，请自行查看API学习，总体感觉：UIButton更丰富多彩了！\n","date":"2021-10-16T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2021/20211016.jpeg","permalink":"https://pitiaotiao.github.io/p/ios-ios15-uibutton-update-api/","title":"iOS15终于迎来了UIButton的这个改动！"},{"content":"第①步：通过npm安装docsify 1 npm i docsify-cli -g 第②步：新建一个GitHub仓库,并开启GitHub Pages 点击Save后，如下图所示：\n⚠️注意：我这里显示abnerpei.com/docsify/是因为我有域名解析处理，正常的应该是github.io/docsify/。\n此时，我的邮箱（GitHub绑定的）收到一封邮件通知\u0026quot;[AbnerPei/docsify]Page build failure\u0026quot;:\n第③步：clone项目，并创建docs文件夹： 1 docsify init ./docs 本地验证一下：\n1 docsify serve ./docs 第④步：配置docsify 下载qufei1993/Nodejs-Roadmap 找到docs目录，然后对照Nodejs技术栈，配置自己的docsify。\n第⑤步：push项目，查看效果 上图报错解决办法：\nremote/ Support for password authentication was removed on August 13, 2021\n参考链接 Docsify快速搭建个人博客 官方文档-快速开始 ","date":"2021-09-23T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2021/20210923.jpeg","permalink":"https://pitiaotiao.github.io/p/20210923/","title":"利用docsify快速创建个人博客"},{"content":"周末在家，天公不做美，大雨！所以，就优化一下之前的一个开源库PPMaker，可是在提交的时候，就遇到了如下的问题：\n不过，庆幸的是，刚好在我搜这个问题2小时前，有人给出了解决方案：\n【GitHub不再支持密码验证解决方案：SSH免密与Token登录配置】\n文中给出了3种方案，我选择了第3种：\n第①步：前往GitHub，复制SSH的url\n第②步：找到PPMaker本地目录下的config文件\n第③步：把HTTPS的url替换成SSH的url\n最后，成功了\n","date":"2021-08-15T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2021/20210815.jpeg","permalink":"https://pitiaotiao.github.io/p/20210815/","title":"git报错：remote/ Support for password authentication was removed on August 13, 2021的解决办法"},{"content":"小实验 1 @property (nonatomic, assign) NSInteger age; 上面的代码，如果是你，你平时怎么在 Xcode 中敲写的呢？\n第一种：从左到右依次敲写\n第二种：采用Code Snippet\n通过我们的肉眼观察，可以很容易的发现：第二种明显更快。\n眼见为虚，那好，我们用数据来说话（控制变量法 + 录屏）：\n唯一不可控的是我在敲代码时的反应，暂且忽略不计。\n第一种用时 14秒，第二种用时及 3秒，可以看出，差别还是很大的（说实在的，我自己之前也一直觉得第二种效率更高，但是没想过如此之高）。\n代码块（Code Snippet） 代码块（Code Snippet），顾名思义，就是一个代码片段。\nCodeSnippets 的文件路径：\n1 ~/Library/Developer/Xcode/UserData/CodeSnippets 如何自定义代码块 创建代码块 注意下图圈中，对应的颜色（左边是敲代码时展示的效果，右边是代码块的配置）。\n这里注意要选择Objective-C（默认是Objective-C++），否则扩展（extension）中无效。\n系统提供的代码块 dispatch_once、dispatch_after 1 2 3 4 5 6 7 8 9 static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ \u0026lt;#code to be executed once#\u0026gt; }); return YES; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(\u0026lt;#delayInSeconds#\u0026gt; * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ \u0026lt;#code to be executed after a specified delay#\u0026gt; }); for、for...in... 1 2 3 4 5 6 7 for (\u0026lt;#initialization#\u0026gt;; \u0026lt;#condition#\u0026gt;; \u0026lt;#increment#\u0026gt;) { \u0026lt;#statements#\u0026gt; } for (\u0026lt;#type *object#\u0026gt; in \u0026lt;#collection#\u0026gt;) { \u0026lt;#statements#\u0026gt; } 自定义的代码块 格式：\u0026lt;#注释#\u0026gt;\n属性 关键字属性\n1 2 3 4 5 6 7 8 9 @property (nonatomic, strong) \u0026lt;#ClassName#\u0026gt; *\u0026lt;#propertyName#\u0026gt;; /// \u0026lt;#注释#\u0026gt; @property (nonatomic, strong) \u0026lt;#ClassName#\u0026gt; *\u0026lt;#propertyName#\u0026gt;; @property (nonatomic, assign) \u0026lt;#TypeName#\u0026gt; \u0026lt;#propertyName#\u0026gt;; /// \u0026lt;#注释#\u0026gt; @property (nonatomic, assign) \u0026lt;#TypeName#\u0026gt; \u0026lt;#propertyName#\u0026gt;; 具体属性\n1 2 3 4 5 6 7 8 9 @property (nonatomic, strong) UILabel *\u0026lt;#XX#\u0026gt;Label; /// \u0026lt;#注释#\u0026gt; @property (nonatomic, strong) UILabel *\u0026lt;#XX#\u0026gt;Label; @property (nonatomic, copy) NSString *\u0026lt;#propertyName#\u0026gt;; /// \u0026lt;#注释#\u0026gt; @property (nonatomic, copy) NSString *\u0026lt;#propertyName#\u0026gt;; 懒加载 UILabel/UIImageView等的懒加载\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 - (UILabel *)\u0026lt;#yourLabel#\u0026gt; { if (!_\u0026lt;#yourLabel#\u0026gt;) { _\u0026lt;#yourLabel#\u0026gt; = [[UILabel alloc] init]; } return _\u0026lt;#yourLabel#\u0026gt;; } - (UIImageView *)\u0026lt;#yourImageView#\u0026gt; { if (!_\u0026lt;#yourImageView#\u0026gt;) { _\u0026lt;#yourImageView#\u0026gt; = [[UIImageView alloc] init]; } return _\u0026lt;#yourImageView#\u0026gt;; } NSArray/NSMutableArray有泛型的懒加载\n1 2 3 4 5 6 7 - (NSMutableArray\u0026lt;\u0026lt;#GenericsName#\u0026gt; *\u0026gt; *)\u0026lt;#yourMArray#\u0026gt; { if (!_\u0026lt;#yourMArray#\u0026gt;) { _\u0026lt;#yourMArray#\u0026gt; = [NSMutableArray array]; } return _\u0026lt;#yourMArray#\u0026gt;; } NSArray/NSMutableArray无泛型的懒加载\n1 2 3 4 5 6 7 - (NSMutableArray *)\u0026lt;#yourMArray#\u0026gt; { if (!_\u0026lt;#yourMArray#\u0026gt;) { _\u0026lt;#yourMArray#\u0026gt; = [NSMutableArray array]; } return _\u0026lt;#yourMArray#\u0026gt;; } 方法调用 delegate先判断再执行 Masonry使用 其它（Every or any, if you want!） 代码块的优点 避免重复代码反复敲写，减少不必要的时间浪费 （如小实验的实验） 快速演示（详见每年的WWDC） 不常用的方法，可以特殊处理（我一般用来处理个别系统适配）。 统一编码规范 最后 代码块（Code Snippet）真的是个很好用的东东，平时闲了，可以整理一份适合自己的代码块，然后通过GitHub/gitee进行备份。如果不想整理，也可以去GitHub/gitee搜一些拿来用，但我真的建议还是自己整理一份。\n附：最新整理的CodeSnippets\n为了方便后续修改（新增、删除）后依然能及时同步，我这里备份在gitee上ap_code_snippets_oc，同时，我也加入了install.sh，方便终端快速替换：\n1 2 /// 进入本地的ap_code_snippets_oc目录，执行如下命令即可： sh install.sh 替换完，记得要重启Xcode。\n","date":"2021-05-02T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2021/20210502.jpeg","permalink":"https://pitiaotiao.github.io/p/20210502/","title":"iOS代码块（CodeSnippets）你值得拥有：大大提升编码效率"},{"content":"PPMaker是什么❓ 声明：PPMaker跟Masonry功能上是完全不同的库，PPMaker是快速便捷创建UI/attributedText等的，而Masonry是布局的。\n做iOS开发，创建UI控件，必须的不说，还多，尤其你新入手一个项目。\n我自己写代码，向来想省事：怎么能不一个一个属性写？ 带着这个问题，我刚开始创建了各种Tool来处理，后来用Category，可Category有个烦人的问题：有些属性我不需要但是方法参数有，而有些属性我需要方法参数没有。\n昨天，看到臧成威的如何利用Objective-C写一个精美的DSL，挺好，就想着优化下自己的代码，于是就有了 PPMaker.\n在此，献上对臧老师的感谢。\nPPMaker的不同（优点） ①、链式调用，代码简洁\n②、点语法后面有提示（Masonry是没有的 ）\n③、不需要终结词，臧老师给的示例有\n④、不需要助词 （如Masonry中的with），这个也可以说是一个缺点吧\n⑤、pod可根据需求随意选择\n⑥、不需要的属性，根本不用管 主要对比Category\nPPMaker的用法 第一步、导入PPMaker\n方法一、使用CocoaPods安装 1 pod \u0026#39;PPMaker\u0026#39;, \u0026#39;~\u0026gt; 0.0.22\u0026#39; 方法二、手动下载拖入 第二步、用对应的类（如:UILable）直接调用pp_\n使用示例：创建一个简单的UILabel对象\nmaker调用，直接调UILabel对象的属性，如text、textColor、frame等，当然也有自定义的，如intoView表示要加到哪个view上、fontSize实际上[UIFont systemFontOfSize:fontSize]的简化等等。\n总之，PPMaker is very easy to use。\n回顾：创建UI控件的路程 起初：一个属性一个属性赋值 1 2 3 4 5 6 7 UILabel *lb = [[UILabel alloc]initWithFrame:CGRectMake(10, 10, 300, 50)]; [self.view addSubview:lb]; lb.backgroundColor = [UIColor whiteColor]; lb.text = @\u0026#34;我是一个lb\u0026#34;; lb.textColor = [UIColor blueColor]; lb.textAlignment = NSTextAlignmentCenter; lb.font = [UIFont systemFontOfSize:18]; 后来：用Category快速创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @interface UILabel (EasyMake) +(UILabel *)lbMakeWithSuperV:(UIView *)superV frame:(CGRect)frame font:(UIFont *)font alignment:(NSTextAlignment)alignment text:(NSString *)text textColor:(UIColor *)textColor; @implementation UILabel (EasyMake) +(UILabel *)lbMakeWithSuperV:(UIView *)superV frame:(CGRect)frame font:(UIFont *)font alignment:(NSTextAlignment)alignment text:(NSString *)text textColor:(UIColor *)textColor { UILabel *lb = [[UILabel alloc]init]; if (superV) { [superV addSubview:lb]; } if (font) { lb.font = font; } if (text) { lb.text = text; } if (textColor) { lb.textColor = textColor; } lb.frame = frame; lb.textAlignment = alignment; return lb; } @end 现在：链式调用的DSL\n结语 PPMaker是自己写的最满意的一个库之一，解决了自己一直以来创建UI、配置attributedText 的苦恼，这其中也参考了一些大神的的blog和开源库，在此，表示感谢。今天，分享自己的这个库，希望帮助像我一样的同学，其次，希望觉得好的，给个star。\n当然了，这个库，我会持续更新的，有什么问题，欢迎提出来。或者谁有更好的做法，热烈欢迎告知一下，深表谢意！\n","date":"2018-05-09T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2018/20180509.jpeg","permalink":"https://pitiaotiao.github.io/p/ios%E9%93%BE%E5%BC%8F%E5%88%9B%E5%BB%BAui%E7%BB%88%E7%BB%93%E8%80%85-ppmaker/","title":"iOS链式创建UI终结者 ➜ PPMaker"},{"content":"一、前言 最近在解答[最新版]MJRefresh解析与详细使用指导和MJRefresh实现刷新（使用它的Block方法）中简友的提问，浅读了下 MJRefresh 的源码 (关于源码解读，网上已有很多，我后续也会写一篇我自己的解读，不过今天要说的是：借鉴别人的思路，做or完善自己的事。):\n利用KVO在- (void)willMoveToSuperview:(UIView *)newSuperview方法调用时监听scrollView的contentOffset/contentSize和panGestureRecognizer的state属性，然后做对应操作。\n二、开发困惑 通常，作为iOS开发人员，判断UIScrollView/UITableView/UICollectionView的滚动情况的事，时有发生。如果每次都去实现delegate方法，在我看来，有些麻烦。除了一遍一遍的写代理，还有一种就是建个基类，但是这样基类还是要实现对应的delegate方法。\n三、解决方法：给UIScrollView添加block属性监听滚动 先预览下效果(上面红色的是手机录屏所致)： 四、理清思路 新建一个类 PPMJRefreshComponent,类似MJRefresh中的MJRefreshComponent，用来当做观察者; 既然 PPMJRefreshComponent 要观察 UIScrollView 的contentOffset以及panGestureRecognizer的state,那么 PPMJRefreshComponent 就要关联当前的 UIScrollView；并且，UIScrollView 要拥有一个 PPMJRefreshComponent 对象（如下图：）； PPMJRefreshComponent 观察的结果怎么传递给 UIScrollView？我采用的是delegate(PPMJRefreshComponentDelegate),需要 UIScrollView 对象遵守；（此处不使用block是因为block嵌套block容易出问题） UIScrollView 对象实现代理，并设置scrollBlock的时候触发监听：(代码如下，注释已写进去) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @implementation UIScrollView (ScrollBlock) #pragma mark --- PPMJRefreshComponentDelegate -(void)scrollViewContentOffsetDidChange:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change{ [self contentOffsetBlockAction:change]; } -(void)scrollViewPanStateDidChange:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change{ [self panGestureRecognizerStateAction:change]; } -(void)contentOffsetBlockAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change { //这个属性字面理解意思为：正在拖动。实际上是：scrollView是否滚动了，只要不是最开始初始化的时候设置的位置，就为YES。 if (!self.isDragging) { return; } //【注意】此处要特别注意，如果设置contentInset的话，要给pp_lastContentOffsetY赋值为insetT的初始值 if (!self.pp_lastContentOffsetY) { [self setupInitializeOffsetY]; } //获取当前的contentOffsetY CGFloat currentContentOffsetY = self.pp_FSB_offsetY; //如果前后的contentOffsetY值相同，就不做处理 CGFloat lastContentOffsetY = [self.pp_lastContentOffsetY floatValue]; if (currentContentOffsetY == lastContentOffsetY) { return; } //是否是向上滑，初始值为NO BOOL isToUp = NO; //向上滑动 if (currentContentOffsetY \u0026gt; lastContentOffsetY) { //处理滑动到底部，继续上滑后系统自动反弹而重复调用的情况 if (currentContentOffsetY+self.pp_h \u0026gt; self.pp_FSB_contentH) { return; } isToUp = YES; }else{ //向下滑动 //处理已经最上面了仍然下拉而反弹时，反复调用 if (currentContentOffsetY \u0026lt;= self.pp_FSB_insetT) { return; } } //给pp_lastContentOffsetY绑定值 objc_setAssociatedObject(self, @selector(pp_lastContentOffsetY), [NSNumber numberWithFloat:currentContentOffsetY], OBJC_ASSOCIATION_RETAIN); //是否超过一个屏幕 BOOL isInOneScreen = (self.pp_FSB_insetT+self.pp_FSB_contentH \u0026lt;= self.pp_h); if (self.pp_scrollBlock) { self.pp_scrollBlock(currentContentOffsetY, isToUp,isInOneScreen); } } -(void)panGestureRecognizerStateAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change { if (self.panGestureRecognizer.state == UIGestureRecognizerStateEnded) { //内容不够一个屏幕时，系统会自动回弹，这时候记得把pp_lastContentOffsetY重新设置一下 if (self.pp_FSB_insetT+self.pp_FSB_contentH \u0026lt;= self.pp_h) { [self setupInitializeOffsetY]; }else{ //超过一个屏幕,这时候下拉，当松开的时候要把pp_lastContentOffsetY重新设置一下 if (self.pp_FSB_offsetY \u0026lt; self.pp_FSB_insetT) { [self setupInitializeOffsetY]; } } } } #pragma mark --- 初始化contentOffsetY的值 -(void)setupInitializeOffsetY{ CGFloat currentContentOffsetY = -self.pp_FSB_insetT; objc_setAssociatedObject(self, @selector(pp_lastContentOffsetY), [NSNumber numberWithFloat:currentContentOffsetY], OBJC_ASSOCIATION_RETAIN); } -(void)setPp_scrollBlock:(PPUIScrollViewScrollBlock)pp_scrollBlock { //在设置scrollBlock的时候，触发监听 self.pp_component.delegate = self; objc_setAssociatedObject(self, @selector(pp_scrollBlock), pp_scrollBlock, OBJC_ASSOCIATION_RETAIN); } -(PPUIScrollViewScrollBlock)pp_scrollBlock { return objc_getAssociatedObject(self, _cmd); } @end 针对上面的代码补充说明如下：\n注意 component 的初识与关联，一定要弄懂为啥我代码中要用runtime强制关联; 注意 pp_lastContentOffsetY 的使用，它是给 UIScrollView 动态绑定的记录上一次的contentOffsetY值的，只有在滑动的时候有效，最终如果你放外部的话，偏移量还是和contentOffset.Y的值一样。 -(void)contentOffsetBlockAction:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change这个方法处理滑动情况，但是 开始下拉 和 上拉到底 的两种临街状态时的 pp_lastContentOffsetY 需要特殊处理，而这个处理就放在panGestureRecognizer.state == UIGestureRecognizerStateEnded的时候。 最后，感谢 MJRefresh！\n2018-03-08 14:20:40 妇女节快乐！ 感谢公司的 party,此刻 吃着零食喝着饮料，匆匆结文。\n","date":"2018-03-08T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2018/20180308.jpeg","permalink":"https://pitiaotiao.github.io/p/20180308/","title":"浅读MJRefresh后自定义了个UIScrollView监听滚动的block属性"},{"content":" 某天，闲来无聊点击微信通讯录右边的索引（具体操作如下：打开微信\u0026mdash;通讯录，然后右手点击某个索引，手指别松开，然后左手点击某个联系人cell，跳转后再返回，你刚才长按的放大索引还在，并且再滑动，索引对应字母也不变化，索引视图卡住。），发现了这个bug（我都滑动到L了，放大的索引还是M），如下：\n由于自己的项目也有类似的功能，同样操作，也有同样的bug，于是就赶紧修复一下。\n问题有了，解决问题的关键就是找到原因并给出合理的解决方案。\nWhy?\nWhy?\nWhy?\n原因：放大的索引视图在显示的情况下点击tableViewCell没有隐藏掉.\n解决方案：在didSelectRowAtIndexPath方法里隐藏(or移除)放大了的索引视图。\n方案一：用通知，didSelectRowAtIndexPath调用的时候给**PPSectionTitleIndexView**发个通知。 方案二 ：用runtime，didSelectRowAtIndexPath调用的时候给UItableView添加一个block,**PPSectionTitleIndexView**里面的tableView实现block。 两种方案对比：\n方案一: 需要每次调用didSelectRowAtIndexPath时都要发送一个通知；\n方案二: 什么也不用做。所以，当然方案二更好。\n扯了那么多，现在进入实战。\n第一步 ：创建PPSectionTitleIndexView继承自UIView，并声明代理PPSectionTitleIndexViewDelegate，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #import \u0026lt;UIKit/UIKit.h\u0026gt; NS_ASSUME_NONNULL_BEGIN @protocol PPSectionTitleIndexViewDelegate \u0026lt;NSObject\u0026gt; @required /** 与PPSectionTitleIndexView相关联的view（UITableView） */ -(UITableView *)sectionTitleIndexViewAssociatedView; /** section的titles */ -(NSArray\u0026lt;NSString *\u0026gt; *)sectionTitleIndexViewSectionTitles; @end @interface PPSectionTitleIndexView : UIView /** 索引是否正在显示 */ @property(nonatomic,assign,readonly) BOOL isShowingIndex; //这三种不能用于初始化 -(instancetype)initWithFrame:(CGRect)frame NS_UNAVAILABLE; -(instancetype)init NS_UNAVAILABLE; +(instancetype)new NS_UNAVAILABLE; -(instancetype)initWithFrame:(CGRect)frame delegate:(_Nullable id\u0026lt;PPSectionTitleIndexViewDelegate\u0026gt;)delegate NS_DESIGNATED_INITIALIZER; +(instancetype)pp_sectionTitleIndexViewWithFrame:(CGRect)frame delegate:(_Nullable id\u0026lt;PPSectionTitleIndexViewDelegate\u0026gt;)delegate; @end NS_ASSUME_NONNULL_END 第二步：设置PPSectionTitleIndexView 思路：每个索引用UIButton,当前点击的放大索引用UILabel显示。\n核心代码如下：\n1.创建UI的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 -(instancetype)initWithFrame:(CGRect)frame delegate:(id\u0026lt;PPSectionTitleIndexViewDelegate\u0026gt;)delegate { self = [super initWithFrame:frame]; if (self) { self.delegate = delegate; [self creatUI]; } return self; } -(void)creatUI { //1. 先检验必须实现的协议有没有实现 [self verifyRequiredProtocol]; //2. 创建索引UI [self creatIndexUI]; //3. 添加平移手势 [self addPanGesture]; } //此处只贴出来index的button创建代码 for (int i = 0; i\u0026lt;self.indexTitles.count; i++) { UIButton *item = [UIButton buttonWithType:UIButtonTypeCustom]; [self addSubview:item]; item.tag = 100+i; item.frame = CGRectMake(0, topOrBottomMargin+(oneIndexWidth+itemMargin)*i, indexVWidth, oneIndexWidth); item.titleEdgeInsets = UIEdgeInsetsMake(0, self.frame.size.width-oneIndexWidth-5, 0, 5); [item setTitle:self.indexTitles[i] forState:UIControlStateNormal]; [item setTitle:self.indexTitles[i] forState:UIControlStateHighlighted]; [item setTitleColor:[UIColor blueColor] forState:UIControlStateNormal]; [item setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted]; item.backgroundColor = [UIColor clearColor]; item.titleLabel.font = [UIFont systemFontOfSize:12]; [item addTarget:self action:@selector(btnClickedDown:) forControlEvents:UIControlEventTouchDown]; //只要点击 [item addTarget:self action:@selector(btnTouchUpInside:) forControlEvents:UIControlEventTouchUpInside]; //点击松手 } 2.响应事件的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -(void)btnClickedDown:(UIButton *)sender { //1. 获取当前sectionTitle的frame CGRect currentSectionTitleRect = [self.tableView rectForSection:sender.tag-100]; //2. 把tableView当前section滚动到top (不要动画效果更好) [self.tableView setContentOffset:CGPointMake(currentSectionTitleRect.origin.x, currentSectionTitleRect.origin.y) animated:NO]; //3. 把当前的index放大显示到屏幕中间 NSString *currentIndexStr = sender.titleLabel.text; self.currentIndexShowLB.text = currentIndexStr; //4. 处理indexStr if (currentIndexStr.length == 1) { self.currentIndexShowLB.font = [UIFont systemFontOfSize:35]; }else{ self.currentIndexShowLB.font = [UIFont systemFontOfSize:18]; } //5. 屏幕中间显示当前index self.currentIndexShowLB.hidden = NO; } -(void)btnTouchUpInside:(UIButton *)sender { //该方法是在btnClickedDown后执行 self.currentIndexShowLB.hidden = YES; } #pragma mark --- 添加平移手势 -(void)addPanGesture { UIPanGestureRecognizer *panGR = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panAction:)]; [self addGestureRecognizer:panGR]; } -(void)panAction:(UIPanGestureRecognizer *)panGR { //1. 获取手指当前位置的point CGPoint fingerTapPoint = [panGR locationInView:self]; //2. 遍历self上的所有自视图（UIButton *）,如果它的tag和上次不一样，执行touchDown方法 for (UIView *aV in self.subviews) { if ([aV isKindOfClass:[UIButton class]] \u0026amp;\u0026amp; aV.tag != _selectedBtnTag \u0026amp;\u0026amp; CGRectContainsPoint(aV.frame, fingerTapPoint)) { _selectedBtnTag = aV.tag; [self btnClickedDown:(UIButton *)aV]; } } //3. 手势结束时，隐藏屏幕中间的showIndexLB if (panGR.state == UIGestureRecognizerStateEnded) { self.currentIndexShowLB.hidden = YES; } } 至此，想要的功能算是实现了，但是文章一开始提到的bug也出现了，😜。\n第三步：解决Bug 关键：tableView的Category\nruntime方案的实现步骤如下：\n拦截UITableView的系统setDelegate，用pp_setDelegate替换； 判断delegate是否响应系统的tableView:didSelectRowAtIndexPath: ，如果响应才能继续3； 根据系统的代理tableView:didSelectRowAtIndexPath: 方法和对应的指针给代理类[delegate class]利用runtime的class_addMethod添加一个didSelected方法@selector(pp_fakeTableView:didSelectRowAtIndexPath:)，并替换为pp_tableView:didSelectRowAtIndexPath:. 利用NSInvocation在替换的didSelected方法pp_tableView:didSelectRowAtIndexPath:中调用pp_fakeTableView:didSelectRowAtIndexPath:,因为pp_fakeTableView:didSelectRowAtIndexPath:和系统的tableView:didSelectRowAtIndexPath:指针指向相同，所以就相当于调用系统的tableView:didSelectRowAtIndexPath:，这样就实现了我们的需求。 我怕我说明的不清楚，特意画了个图：\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 ///** // * 通过给定的方法名和实现，动态给类添加一个方法 // * // * @param cls 要添加方法的类. // * @param name 指定了方法名的要添加到类的方法. // * @param imp 添加方法的函数实现（函数地址). // * @param types 函数的类型，(返回值+参数类型). // * // * @return 如果添加成功就返回YES，失败返回NO（如果该类中已经存在一个相同的方法名的方法实现）. // * // * @note 注: class_addMethod将重写父类的实现，但是不会替换该类中已经有的实现， // 如果想改变该类中已有的实现，请使用method_setImplementation // */ //OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp,const char * types) -(void)pp_setDelegate:(id\u0026lt;UITableViewDelegate\u0026gt;)delegate { if(delegate){ //系统原生的didSelected方法 SEL systemDidSelectedSelector = @selector(tableView:didSelectRowAtIndexPath:); //我自己重写的didSelected方法（用于替换系统的） SEL ppDidSelectedSelector = @selector(pp_tableView:didSelectRowAtIndexPath:); //VIP：假的didSelected方法（和系统原生的didSelected方法指针地址相同，但不是一个方法，却响应同样事件） SEL fakeDidSelectedSelector = @selector(pp_fakeTableView:didSelectRowAtIndexPath:); if ([delegate respondsToSelector:systemDidSelectedSelector]) { //系统的代理didSelected方法和对应的指针 Method systemDidSelectedMethod = class_getInstanceMethod([delegate class], @selector(tableView:didSelectRowAtIndexPath:)); IMP systemDidSelectedMethodIMP = method_getImplementation(systemDidSelectedMethod); //VIP：此处给系统原生的didSelected方法上添加新的方法（只要方法名不一样，就可以成功，详见系统api中的@return说明） //注意此方法放置位置，不能放在下面的class_replaceMethod后面（因为已经被替换了，指针会指向tableView *的pp_tableView:didSelectRowAtIndexPath:） class_addMethod([delegate class], fakeDidSelectedSelector, systemDidSelectedMethodIMP, method_getTypeEncoding(systemDidSelectedMethod)); //自己重写的didSelected，用来处理拦截后想做的事情（比如：发通知，block回调等） Method ppDidSelectedMethod = class_getInstanceMethod([self class], ppDidSelectedSelector); IMP ppDidSelectedMethodIMP = method_getImplementation(ppDidSelectedMethod); //用自己重写的替换系统原生的 class_replaceMethod([delegate class], systemDidSelectedSelector, ppDidSelectedMethodIMP, method_getTypeEncoding(systemDidSelectedMethod)); } } //拦截原生的delegate，别忘了调用（此处调用pp_setDelegate:实际上就是调用setDelegate:，说句不该说的话，此处看不懂，runtime你根本不会） [self pp_setDelegate:delegate]; } -(void)pp_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { //方案(通知)都用的到的通知，很显然太费事，不方便 /* NSNotification *not = [[NSNotification alloc]initWithName:PPTableViewDidSelectedNotificationKey object:nil userInfo:nil]; [[NSNotificationCenter defaultCenter]postNotification:not]; */ //方案（runtime）：给tableView添加点击block，。。。。嗯，有没有想到更多？？简化所有的delegate与dataSource方法，此处不说太多 if (tableView.pp_didSelectedBlock) { tableView.pp_didSelectedBlock(tableView, indexPath); } //VIP: 此时，系统原生的didSelected方法已经被拦截，并且做了你想做的事情，可是怎么让系统原生的didSelected还能响应点击？ /* 方案一： 不用class_addMethod方法，而是在[delegate respondsToSelector:systemDidSelectedSelector]条件语句里 添加代理绑定： objc_setAssociatedObject(PPTableViewDidSelectedNotificationKey, @selector(pp_tableView:didSelectRowAtIndexPath:), delegate, OBJC_ASSOCIATION_RETAIN); 然后在此处，执行： id ppDelegate = objc_getAssociatedObject(PPTableViewDidSelectedNotificationKey, _cmd); [ppDelegate pp_tableView:tableView didSelectRowAtIndexPath:indexPath]; 哦😯，傻了，这相当于直接调用系统的didSelected方法，/(ㄒoㄒ)/~~，错！错！错！ */ //方案二：利用NSInvocation底层发消息，如下： SEL fakeDidSelectedSelector = @selector(pp_fakeTableView:didSelectRowAtIndexPath:); NSMethodSignature *methodSignature = [[tableView.delegate class]instanceMethodSignatureForSelector:fakeDidSelectedSelector]; if (methodSignature == nil) { //可以抛出异常也可以不操作。 } NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:methodSignature]; invocation.target = tableView.delegate; invocation.selector = fakeDidSelectedSelector; [invocation retainArguments]; [invocation invoke]; } 2017年最后一天了，一首歌共勉： ","date":"2017-12-31T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2017/20171231.jpeg","permalink":"https://pitiaotiao.github.io/p/20171231/","title":"runtime实战系列（一）--- 微信通讯录bug的完美解决"},{"content":" 我 ：“2017年还有多久？”\n我 ：“ ‘冬天来了，春天还会远吗？’，马上就要步入2018年，您说2017年还有多久。您就看着吧，下个月到处都是2017年年终总结！”\nI\u0026rsquo;sorry,进入正题：\n我个人写本文的目的只有一个：让你轻松制作自己的pod库 。可能是因为我笨？网上的教程，我看的有点😓（晕），不过最终还是摸索出来了，并且明白了123，so，请允许我以我“笨”的方式来让你轻松。\n第①步：在GitHub上新建一个仓库 说明：由于自己创建PPKit时没有截图，这里为了说明，新建了PPKit1来截图说明，谅解！\n第②步：clone项目到本地，并创建.podspec文件 具体clone与创建.podspec文件的命令如下：\n1 2 3 4 5 6 7 8 //2.1（具体路径，看你自己放置） cd /Users/peijianbo/Documents/MTTest //2.2 git clone https://github.com/chinesemanbobo/PPKit1.git //2.3 (切换到开源库名相同的目录) cd /Users/peijianbo/Documents/MTTest/PPKit1 //2.4 （很重要的第一步，create后面必须是开源库名，此处是PPKit1） pod spec create PPKit1 至此，会出现Specification created at PPKit1.podspec。Good!\n第③步：配置.podspec，尤其是里面的.source_files文件要注意 注意：此处开始，我们再回到PPKit。（如果你自己的库，请替换PPKit为你的库名来阅读）。\n3.1 打开PPKit.podspec文件（我用的是Sublime Text，提示、关键字高亮处理的比较好），我觉得很有必要读读开头的3行注释，真的是很有必要。（我自己就是因为后来才读这3行注释，中间浪费了很多时间）。下面，我简单翻译下：\n1 2 3 4 5 6 # Be sure to run `pod spec lint PPKit.podspec\u0026#39; to ensure this is a # valid spec and to remove all comments including this before submitting the spec. # # To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html # To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/ # 在你提交.podspec文件到CocoaPods前，务必要在命令行运行pod spec lint PPKit.podspec来确保.podspec有效，并且删除所有的注释，包括这句（Be sure \u0026hellip; submitting the spec.）。 你可以在cocoapods.org看到更多关于podspec(pod规则)的属性的信息。 你可以在GitHub上查看当前都有那些有效的、可以用的Pods. 上面第3条，我们可以点开看一看，保证你有收获，如下：\n点开后，在This repository里输入**AFNetworking**,然后摁Enter键搜索，你会看到下图，先别惊奇(至于我再下面截图上说的，本地也有，就不上图了)： 看到这，如果你的项目用到了CocoaPods,有没有一种 “噢\u0026hellip;，原来是这样的”的柳暗花明又一村的感觉，如果你有，你NB；如果没有，没有就算了，你更要认真看下去！反正我有。嘿嘿！\n放大招的时候来了：CocoaPods说白了，就是帮我们管理第三方or自己的库；而它不过也是一个.xcodeproj工程。只不过，它是专门管理第三方or自己的库的工程，而它的工作原理就是：你把.podspec文件制作好，然后trunk push (后面后讲到)给它，它再把.podspec文件保存为.podspec.json文件放到GitHub，你需要的话，它通过这个.podspec.json把GitHub上对应的开源库的文件下载下来，放到你的工程里。至此，OK。\n说了这么多，再来张图，证实下，我们继续讲Pod库的制作，图如下（不信也不行）：\n那就打开PPKit.podspec,删除里面所有的注释。然后修改，下面给出PPKit.podspec以便参考，注释我以及加进去（如果你发布的话，最好注释去掉，此处只是为了说明）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Pod::Spec.new do |s| #开源库的名字 s.name = \u0026#34;PPKit\u0026#34; #开源库当期版本 s.version = \u0026#34;0.0.6\u0026#34; #开源库概述（打开GitHub能看到的描述） s.summary = \u0026#34;开发中常用的自定义控件、开发经验、开发bug记录，常用宏、categories等封装，不再每个项目都手动配置，用Pod统一管理。\u0026#34; #开源库描述 （这个描述会被用来生成开源库的标签和提高被搜到，必需写在中间一行，只要在中间一行，不需要考虑缩进） s.description = \u0026lt;\u0026lt;-DESC 开发中经常从A项目copy一些代码（比如常用的宏、category等）到B项目，A更改了一个category，B又要改动；B更改了一个category，A也要改动，不方便同步，就容易出差错，所以，考虑用Pod来管理。 DESC #可以是开源库的GitHub地址，也可以是你自己的网址等 s.homepage = \u0026#34;https://github.com/chinesemanbobo/PPKit\u0026#34; #我这里是参靠网上的一种写法，不会报警告，也可以直接 s.license = \u0026#39;MIT\u0026#39; s.license = { :type =\u0026gt; \u0026#39;MIT\u0026#39;, :text =\u0026gt; \u0026lt;\u0026lt;-LICENSE Copyright PPAbner 2016-2017 LICENSE } #开源库作者 s.author = { \u0026#34;chinesemanbobo\u0026#34; =\u0026gt; \u0026#34;chinesemanbobo@163.com\u0026#34; } #开源库作者的社交链接（此处我放的是微博） s.social_media_url = \u0026#34;https://weibo.com/5366568018/profile?rightmod=1\u0026amp;wvr=6\u0026amp;mod=personnumber\u0026amp;is_all=1\u0026#34; #开源库支持的平台（暂时没考虑tvOS、OSX等） s.platform = :ios #开源库最低支持 s.ios.deployment_target = \u0026#34;8.0\u0026#34; #VIP 开源库GitHub的路径与tag值，GitHub路径后必须有.git,tag实际就是上面的版本 s.source = { :git =\u0026gt; \u0026#34;https://github.com/chinesemanbobo/PPKit.git\u0026#34;, :tag =\u0026gt; s.version } #VIP 开源库资源文件 （我自己总结：每个文件都要有自己的路径，尤其你想目录分的比较详细的话，更具体的说明，看图对比着再说） s.source_files = \u0026#39;PPKit/PPKit.h\u0026#39;,\u0026#39;PPKit/PPMacros.h\u0026#39; #子目录PPHelpers（2级），PPKit(1级)，ss子目录可以随便写，但下面要对应 s.subspec \u0026#39;PPHelpers\u0026#39; do |ss| #子目录PPRuntimeHelper.h和PPRuntimeHelper.m （3级） ss.source_files = \u0026#39;PPKit/PPHelpers/PPRuntimeHelper.{h,m}\u0026#39; end s.subspec \u0026#39;PPCategories\u0026#39; do |ss| ss.subspec \u0026#39;UI\u0026#39; do |ssui| ssui.subspec \u0026#39;UIScreen\u0026#39; do |ssuiscreen| ssuiscreen.source_files = \u0026#39;PPKit/PPCategories/UI/UIScreen/UIScreen+EasilySize.{h,m}\u0026#39; end end end #开源库头文件 s.public_header_files = \u0026#39;PPKit/PPKit.h\u0026#39; #开源库依赖库 # s.dependency \u0026#34;JSONKit\u0026#34;, \u0026#34;~\u0026gt; 1.4\u0026#34; # 是否支持arc s.requires_arc = true end 3.2 .podspec里面的.source_files的常见语法\n一个宗旨：库里面每个文件、资源都要有路径指向它。\n1 2 3 \u0026#34;PPKit/*\u0026#34; 表示匹配所有PPKit目录下文件，不包含子目录的 \u0026#34;PPKit/PPHelpers/*.{h,m}\u0026#34; 表示匹配PPHelpers所有以.h和.m结尾的文件 \u0026#34;PPKit/**/*\u0026#34; 表示匹配所有文件(主目录和子目录，其中**相当于省略中间层级) 具体的语法示例及截图，见文章最后面（参考链接之前）。\n第④步：更新GitHub 依次执行下面命令：\n1 2 3 4 5 $ git add -A \u0026amp;\u0026amp; git commit -m \u0026#34;你的更新说明\u0026#34; //tag值要和.podspce里的version相同，并且必须设置 $ git tag \u0026#39;1.0.0\u0026#39; $ git push --tags $ git push origin master 第⑤步：验证.podspec是否有效 1 pod spec lint PPKit.podspec 如果验证不通过，可以执行**pod spec lint PPKit.podspec --verbose**查看详细的ERROR和WARING提示，根据提示依次解决，然后回到第四步重新来一遍。 注意：在重新开始之前，我们要删除远程库的tag和本地的tag，命令如下：\n1 2 $ git tag -d 0.0.68 //删除本地tag $ git push origin :refs/tags/0.0.68 // 删除远程库tag 直到如下图的验证成功。\n第⑥步：提交.podspec到CocoaPods 1 pod trunk push PPKit.podspec 如果是第一次提交，需要先执行下面的命令去CocoaPods注册（填写邮箱，收取验证链接，点击链接，就OK）：\n1 $ pod trunk register 邮箱 \u0026#39;昵称\u0026#39; --description=\u0026#39; 这里写描述\u0026#39; 然后再执行：\n1 pod trunk push PPKit.podspec OLA，到此就结束了，赶紧去pod search一下，看有没有！\n遇到的问题s: pod search PPkit搜不出 【方案一】cocoapods search 获取不到最新库的解决方法 我用的是第二种：执行 pod repo update更新本地仓库，再pod search PPkit ，就能 搜到了。 【方案二】执行 pod search PPkit \u0026ndash;simple\n【方案三】打开~/Library/Caches/CocoaPods,删除search_index.json，该文件会在重新搜索时创建。\n附：从AFNetworking/PPKit/YYKit看podspec语法。 研究了自己常用的开源库的文件目录，其中**AFNetworking是最完美的，也是我最想要的，而其它的大多数都是，所有.h和.m文件都放在一个目录下，比如：IQKeyboardManager**。对比如下图：\n参考[AFNetworking](https://github.com/AFNetworking/AFNetworking)来说明{}里面的共用以及子目录的设置。\n如下图中间的线：AFURLRequestSerialization.h、AFURLRequestSerialization.m以及AFURLResponseSerialization.h和AFURLResponseSerialization.m可以写为'AFNetworing/AFURL{Request,Response}Serialization.{h,m}'。所以：{}里面的用逗号（,）隔开，相当于数学中的组合. Serialization文件不需要指定路径，只需要subspec调用了就好，它处于第2级目录，里面除了上面的4个文件别无其它。但是这4个文件必须指定目录路径，如上面1中所示。 PPKit配置与截图说明，如下：记住那个原则：每个文件/路径都要指定对应的路径。\n由YYKit学会与理解.exclude_files\n.exclude_files，忽略YYKit下的，重新建文件夹（目录）来管理。\n2017-11-24 03:51:40 耗时6个小时写此文！\n参考链接： Cocoapods: pod search无法搜索到类库的解决办法 给自己的开源库添加cocopods支持 让自己的开源项目支持CocoaPods Cocoapods完整使用篇 ","date":"2017-11-24T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2017/20171124.jpeg","permalink":"https://pitiaotiao.github.io/p/20171124/","title":"使用CocoaPods管理iOS库---制作pod篇"},{"content":" [赠语]：Anything you\u0026rsquo;re good at contributes to happiness.\n一、 NSCharacterSet是什么❓ 1.1 先来看下面的例子：\n需求： 有一个字符串: @\u0026ldquo;今天我们来学习NSCharacterSet我们快乐\u0026rdquo;，去除字符串中所有的 @\u0026ldquo;今\u0026rdquo;、@\u0026ldquo;我\u0026rdquo;、@\u0026ldquo;s\u0026rdquo;。 【注意】s是小写\n思考：如果是你怎么解决？\n自己写。 用 NSCharacterSet。 1.1.1 自己写,如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 NSString *str = @\u0026#34;今天我们来学习NSCharacterSet我们快乐\u0026#34;; NSString *str1 = @\u0026#34;我s今\u0026#34;; NSMutableString *resultStr = [[NSMutableString alloc]init]; for (int i = 0; i \u0026lt; str.length; i++) { NSString *indexStr = [str substringWithRange:NSMakeRange(i, 1)]; if (![str1 containsString:indexStr]) { [resultStr appendString:indexStr]; } } NSLog(@\u0026#34;自己写---%@\u0026#34;,resultStr); //2016-12-23 13:19:42.584 PPDemos[9065:6978391] 自己写---天们来学习NSCharacterSet们快乐 1.1.2 用NSCharacterSet,如下： 1 2 3 4 5 NSString *str = @\u0026#34;今天我们来学习NSCharacterSet我们快乐\u0026#34;; NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@\u0026#34;我s今\u0026#34;]; NSArray *setArr = [str componentsSeparatedByCharactersInSet:characterSet]; NSString *resultStr1 = [setArr componentsJoinedByString:@\u0026#34;\u0026#34;]; NSLog(@\u0026#34;拆分后的字符串数组------%@\\n最终字符串------%@\u0026#34;,setArr,resultStr1); 总结： 至此，通过上面的两个方法，已经解决了需求的问题。通过自己写，结合用NSCharacterSet，可以推断出NSCharacterSet类似一个 字符串处理工具类，而事实上，由名字也可以看出，它确实是！\n二、 NSCharacterSet的常用API学习 1 2 3 4 /** 001 根据一个给定的字符串获取一个NSCharacterSet对象 */ + (NSCharacterSet *)characterSetWithCharactersInString:(NSString *)aString; // 使用实例，如上例！！ 1 2 /** 002 相反字符串限制 【具体见接下的例子】 */ @property (readonly, copy) NSCharacterSet *invertedSet; 1 2 3 4 5 6 7 8 9 10 11 /** 003 常用快捷方法集合 （常用的，已满足大多数需求） */ + controlCharacterSet + whitespaceCharacterSet //空格 + whitespaceAndNewlineCharacterSet //空格和换行符 + decimalDigitCharacterSet //0-9的数字 + letterCharacterSet //所有字母 + lowercaseLetterCharacterSet //小写字母 + uppercaseLetterCharacterSet //大写字母 + alphanumericCharacterSet //所有数字和字母（大小写不分） + punctuationCharacterSet //标点符号 + newlineCharacterSet //换行 002 的 例子 1 2 3 4 5 6 7 8 NSCharacterSet *set = [NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;]; NSString *str = @\u0026#34;7sjf78sf990s\u0026#34;; NSLog(@\u0026#34;set----%@\u0026#34;,[str componentsSeparatedByCharactersInSet:set]); NSCharacterSet *invertedSet = [[NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;] invertedSet]; NSLog(@\u0026#34;invertedSet----%@\u0026#34;,[str componentsSeparatedByCharactersInSet:invertedSet]); //打印结果如下图： 【可以看出invertedSet后，刚好判断条件相反】 明白了001和002，下面有个需求，该怎么实现？自己想吧！\n需求：textFielf只能输入数字\n三、 NSMutableCharacterSet的常用API学习 NSCharacterSet的，NSMutableCharacterSet都可以用。【这句貌似有些多余】。\n1 2 /** 工能同 invertedSet 方法一样，注意这个没有返回值 */ - (void)invert; 附 textFielf只能输入数字的答案,如下:\n1 2 3 4 5 6 7 8 - (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string { NSCharacterSet *charSet = [[NSCharacterSet characterSetWithCharactersInString:@\u0026#34;0123456789\u0026#34;] invertedSet]; NSString *filteredStr = [[string componentsSeparatedByCharactersInSet:charSet] componentsJoinedByString:@\u0026#34;\u0026#34;]; if ([string isEqualToString:filteredStr]) { return YES; } return NO; } ","date":"2016-12-23T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2016/20161213.jpeg","permalink":"https://pitiaotiao.github.io/p/%E5%AD%A6%E4%BC%9Anscharacterset%E5%86%8D%E4%B9%9F%E4%B8%8D%E6%80%95%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","title":"学会NSCharacterSet，再也不怕各种字符串处理！"},{"content":" PPTextField\nPPTextField 一个属性搞定textfield的各种（纯数字，数字最大个数，价格，字符串长度【区分中英文，不区分】等）限制\n输入完成后，以很快的速度点击键盘时，字符串的后替换掉最后一个，谁有解决方法，求指导！！！谢谢！\n作用：处理各种烦人的限制 在开发中，你是否遇到以下的产品需求：\n1 2 3 4 5 1\u0026gt; 手机号必须是11位纯数字，多了不能输入 2\u0026gt; 密码只能是数字和字母 3\u0026gt; 价格必须保留两位小数，并且用户第一个输入“.”，要变为“0.”，小数点后超过2位不能再输入 4\u0026gt; 一个中文算2个字符，一个英文算1个字符，合起来不超过10个字符 5\u0026gt; 不管你中文英文，最多别超过12个字符 等等，每次都是遵循代理，写一大堆代码，太麻烦了，今天我把这些都集中起来，整理下，分享出来！\nPPTextField简单易用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** 纯数字 */ @property(nonatomic,assign)BOOL isOnlyNumber; /** 最多纯数字个数【isOnlyNumber == yes 有效】，比如手机11位，商品条码13位等 【设置了maxNumberCount,就默认 isOnlyNumber = YES】*/ @property(nonatomic,assign)NSInteger maxNumberCount; /** 价格(只有一个\u0026#34;.\u0026#34;，小数点后保留2位小数) */ @property(nonatomic,assign)BOOL isPrice; /** 价格是否允许以“.”开头，默认是不允许，如果允许，请设置为YES 【设置了isPriceHeaderPoint,就默认 isPrice = YES】*/ @property(nonatomic,assign)BOOL isPriceHeaderPoint; /** 字符串最大长度（一个中文2个字符，一个英文1个字符【中文输入法下的都算中文】） */ @property(nonatomic,assign)NSInteger maxCharactersLength; /** tf.text最大长度（不考虑中英文） */ @property(nonatomic,assign)NSInteger maxTextLength; 嘿嘿，一切都在不言中！！！\n","date":"2016-10-10T00:00:00Z","image":"https://ap-hexo-blog-images.oss-cn-shanghai.aliyuncs.com/BlogCover/2016/20161010.jpeg","permalink":"https://pitiaotiao.github.io/p/20161010/","title":"PPTextField，一个属性搞定UITextField的各种限制，再也不用写一大堆代理了"}]